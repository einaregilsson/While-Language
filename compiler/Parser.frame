/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/

-->begin

-->namespace

import System
import System.Collections.Generic
import While.AST
import While.AST.Statements
import While.AST.Expressions

public class Parser:

-->constants
	private static final T = true

	private static final x = false

	private static final minErrDist = 2

	
	public scanner as Scanner

	public errors as Errors

	
	public t as Token

	// last recognized token
	public la as Token

	// lookahead token
	private errDist as int = minErrDist

	
-->declarations
	
	public def constructor(scanner as Scanner):
		self.scanner = scanner
		errors = Errors()
		self.InitBitset()

	
	private def SynErr(n as int):
		if errDist >= minErrDist:
			errors.SynErr(la.line, la.col, n)
		errDist = 0

	
	public def SemErr(msg as string):
		if errDist >= minErrDist:
			errors.SemErr(t.line, t.col, msg)
		errDist = 0

	
	private def Get():
		while true:
			t = la
			la = scanner.Scan()
			if la.kind <= maxT:
				errDist += 1
				break 
-->pragmas
			la = t

	
	private def Expect(n as int):
		if la.kind == n:
			Get()
		else:
			SynErr(n)

	
	private def StartOf(s as int) as bool:
		return bitset[s][la.kind]

	
	private def ExpectWeak(n as int, follow as int):
		if la.kind == n:
			Get()
		else:
			SynErr(n)
			while not StartOf(follow):
				Get()

	
	
	private def WeakSeparator(n as int, syFol as int, repFol as int) as bool:
		kind as int = la.kind
		if kind == n:
			Get()
			return true
		elif StartOf(repFol):
			return false
		else:
			SynErr(n)
			while not ((bitset[syFol][kind] or bitset[repFol][kind]) or bitset[0][kind]):
				Get()
				kind = la.kind
			return StartOf(syFol)

	
	
-->productions
	
	public def Parse():
		la = Token()
		la.val = ''
		Get()
-->parseRoot
		Expect(0)

	
	private bitset = List[of (bool)]()

	private def InitBitset():
-->initialization

// end Parser

public class Errors:

	public count = 0

	// number of errors detected
	public errorStream as System.IO.TextWriter = Console.Out

	// error messages go to this stream
	public errMsgFormat = '({0},{1}) {2}: {3}'

	// 0=line, 1=column, 2=text
	public def SynErr(line as int, col as int, n as int):
		s as string
-->errors
		else: s = ('error ' + n)
		errorStream.WriteLine(errMsgFormat, line, col, "ERROR", s)
		count += 1

	
	public def SemErr(line as int, col as int, s as string):
		errorStream.WriteLine(errMsgFormat, line, col, "ERROR", s)
		count += 1

	
	public def Warning(line as int, col as int, s as string):
		errorStream.WriteLine(errMsgFormat, line, col, "WARNING", s)

// Errors

public class FatalError(System.Exception):

	public def constructor(m as string):
		super(m)


$$$
