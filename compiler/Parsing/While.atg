/*
 * While Compiler
 * http://code.google.com/p/while-language/
 *
 * Copyright (C) 2009 Einar Egilsson [einar@einaregilsson.com]
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * $HeadURL$
 * $LastChangedDate$
 * $Author$
 * $Revision$
 */
using While.AST;
using While.AST.Expressions;
using While.AST.Sequences;
using While.AST.Statements;

COMPILER Program
	


CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf
COMMENTS FROM "#" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

Program<>
=                                          				(.	StatementSequence statements;
															ProcedureSequence procs = new ProcedureSequence(); 
															Token startTok, endTok; .)

   	(
    IF(IsProcProgram())
    	"begin"											 (.	startTok = t; .)
    	Proc<procs>
    	{
    		Proc<procs>
    	}

    	StmtSeq<statements>
    	"end"											(.	endTok = t; .)
    |
    	StmtSeq<statements>
    )
    
    													(.	WhileProgram.Instance = new WhileProgram(statements, procs);
															if (startTok != null && endTok != null) {
																WhileProgram.Instance.AddSequencePoint(startTok);
																WhileProgram.Instance.AddSequencePoint(endTok);
															}
														.)
.

Proc<ProcedureSequence procs>
=														(.	StatementSequence statements;
															string name;
															List<Variable> valArgs = new List<Variable>();
															Variable resultArg; .)
	"proc"												(.	Token ptok = t; .)
	ident												(.	name = t.val; .)
	"("
	[
		(
			"val"
			ident										(.	Variable v = new Variable(t.val);
															v.IsValueArg = true;
															valArgs.Add(v);
															SymbolTable.DefineArgument(t.val) .)
			[Args<valArgs, resultArg>]
		|
			"res"
			ident										(.	Variable resultArg = new Variable(t.val);
															resultArg.IsResultArg = true;
															SymbolTable.DefineResultArgument(t.val); .)
		)
	]
	")"													(.	SequencePoint seq1 = new SequencePoint(ptok.line,ptok.col, t.line,t.col+t.val.Length); .)
	"is"
	StmtSeq<statements>
	"end"												(.	seq2 = new SequencePoint(t.line, t.col, t.line, t.col+t.val.Length); .)
	";"													(.	if (procs.ContainsProcedure(name)) {
																errors.SemErr(ptok.line, ptok.col, "Procedure '" + name + "' is already declared");
															} else {
																proc = Procedure(name, valArgs, resultArg, statements);
																proc.AddSequencePoint(seq1);
																proc.AddSequencePoint(seq2);
																procs.Add(name, proc);
															}
															SymbolTable.Clear();
														.)
.

Args<VariableSequence vars, ref Variable resultArg> 
=
	(
	IF(IsStartOfResultArg()) 
	","
	"res" 
	ident									(.	resultArg = new Variable(t.val);
												resultArg.IsResultArg = true;
												if (SymbolTable.IsDeclaredInCurrentScope(t.val)) {
													errors.SemErr(t.line, t.col, string.Format("Argument '{0}' is already declared in this scope",t.val));
												} else {
													SymbolTable.DefineResultArgument(t.val);
												}
											.)
	|
	","
	ident									(.	Variable v = new Variable(t.val);
												v.IsValueArg = true;
												valArgs.AddVariable(v);
												if (SymbolTable.IsDeclaredInCurrentScope(t.val)) {
													errors.SemErr(t.line, t.col, string.Format("Argument '${0}' is already declared in this scope",t.val));
												} else {
													SymbolTable.DefineArgument(t.val);
												}
											.)
	[Args<valArgs, resultArg>] 
	)
.

StmtSeq<ref StatementSequence statements>
=													(. 	Statement stmt;
														statements = new StatementSequence();
													.)
    Stmt<stmt>                         				(. statements.AddStatement(stmt); .)
    {
        ';' Stmt<stmt>                 				(. statements.AddStatement(stmt); .)
    }
.

Stmt<ref Statement stmt>
=													(. 	Expression exp;
														int sl = la.line, sc = la.col;
														StatementSequence stmtSeq; 
														Token bf; .)

	( AssignStmt<stmt>								(. stmt.AddSequencePoint((sl,sc, t.line,t.col+t.val.Length)); .)
	| "skip"                               			(. stmt = new Skip();stmt.AddSequencePoint(t); .)
	| BlockStmt<stmt>                       
	| IfStmt<stmt>
	| WhileStmt<stmt>
	| ReadStmt<stmt>								(. 	stmt.AddSequencePoint((sl,sc, t.line,t.col+t.val.Length));.)
	| "write" Expr<exp>                				(. 	stmt = new Write(exp); stmt.AddSequencePoint((sl,sc, t.line,t.col+t.val.Length)); .)
	| CallProc<stmt>								(. 	stmt.AddSequencePoint((sl,sc, t.line,t.col+t.val.Length)); .)
	| 
		'(' 										(.	bf = t; .)
		StmtSeq<stmtSeq> 
		')'											(.	stmt = stmtSeq;
														stmt.AddSequencePoint(bf);
														stmt.AddSequencePoint(t); .)
		
	)
.

ReadStmt<ref stmt as Statement>
=
	"read" 
	(
		ident                         				(. 	stmt = new Read(Variable(t.val)); .)
		|
		'(' 
		ident										(. 	stmt = new Read(Variable(t.val)); .)
		')'
	)
.

VarDecStmt<ref VariableDeclarationSequence vars>
=													(. vars = new VariableDeclarationSequence(); .)
	VarDec<vars>
	{
	    VarDec<vars>
	}
.

VarDec<VariableDeclarationSequence vars>
=
	"var" 											(. 
														int sl = t.line; 
														int sc = t.col;
														int el = la.line;
														int ec = la.col+la.val.Length; .)
	ident                             				(. 	if (SymbolTable.IsDeclaredInCurrentScope(t.val)) {
															errors.SemErr(t.line, t.col, string.Format("Variable '{0}' is already declared in this scope", t.val));
														} else if (SymbolTable.IsInScope(t.val)) {
															errors.Warning(t.line, t.col, string.Format("Variable '{0}' hides variable with same name in outer block",t.val));
															SymbolTable.DefineVariable(t.val);
														} else {
															SymbolTable.DefineVariable(t.val);
														}
														vd = VariableDeclaration(Variable(t.val));
														vd.AddSequencePoint((sl,sc,el,ec));
														vars.AddVariableDeclaration(vd); .)
	';'
.

BlockStmt<ref block as Statement>                 
=
	"begin"                                 		(.	if (CompileOptions.BookVersion) {
															errors.SemErr(t.line, t.col, "Variable declarations are only allowed when using the /coursesyntax switch. Type 'wc.exe /help' for more information")M
															System.Environment.Exit(1);
														}
														VariableDeclarationSequence vars = new VariableDeclarationSequence();
														SymbolTable.PushScope();
														int sl = t.line;
														int sc = t.col;
														int el = t.line;
														int ec = t.col+t.val.Length;
														.)
	[ VarDecStmt<vars> ]							(. StatementSequence statements; .)
	StmtSeq<statements>                
	"end"                       					(. 	Block block = new Block(vars, statements);
														block.AddSequencePoint((sl,sc,el,ec));
														block.AddSequencePoint(t);
														SymbolTable.PopScope(); .)
.

AssignStmt<ref Statement assign>            		(. 	Expression exp;
														Variable var; .)
=	ident                                  			(. 	var = new Variable(t.val);
														if (!SymbolTable.IsInScope(t.val) and not CompileOptions.BookVersion) {
															errors.SemErr(t.line, t.col, string.Format("Assignment to undeclared variable '{0}'",t.val));
														}
													.)
	":="											(. Token tok = t .)
	Expr<exp>                          				(.	if (!ExpectInt(exp, tok, true)) {
															return;
														} 
													.)
													(. assign = new Assign(var, exp); .)
.

IfStmt<ref ifStmt as Statement>           			(. 	ifBranch as StatementSequence; 
														elseBranch as StatementSequence
														tmpStmt as Statement
														exp as Expression
														sl as int
														sc as int
														el as int
														ec as int
													.)
=
	"if"											(.  sl,sc,tok = t.line, t.col, t .)
	Expr<exp>										(.	return unless ExpectBool(exp, tok, true) .)
	"then"											(. 	el,ec = t.line, t.col+t.val.Length .)
	
	(
		IF(CompileOptions.BookVersion) 
			Stmt<tmpStmt>							(.	ifBranch = ToStmtSeq(tmpStmt) .)
			[
			    "else"
				Stmt<tmpStmt>						(.	elseBranch = ToStmtSeq(tmpStmt) .)	
			]
		|
			StmtSeq<ifBranch>
			[
			    "else"
			    StmtSeq<elseBranch>
			]
			"fi"									(.	ifBranch.AddSequencePoint(t)
														elseBranch.AddSequencePoint(t) if elseBranch
													.)

	)
		                                  			(. 	ifStmt = If(exp, ifBranch, elseBranch) 
														ifStmt.AddSequencePoint((sl,sc,el,ec))
													.)
.

WhileStmt<ref whileStmt as Statement>          		(.	exp as Expression
														whileBranch as StatementSequence
														branchStmt as Statement
														sl as int
														sc as int
														el as int
														ec as int.)
=
	"while"											(. 	sl,sc,tok = t.line, t.col,t .)
	Expr<exp>										(. 	return unless ExpectBool(exp, tok, true) .)
	"do"											(.	el,ec = t.line, t.col+t.val.Length .)
	(
		IF(CompileOptions.BookVersion)
		Stmt<branchStmt>							(.	whileBranch = ToStmtSeq(branchStmt) .)
	|
		StmtSeq<whileBranch>
		"od"										(.	whileBranch.AddSequencePoint(t) .)
	)
		                                   			(. 	whileStmt = While(exp, whileBranch) 
														whileStmt.AddSequencePoint((sl,sc,el,ec))
													.)
.

CallProc<ref callStmt as Statement>
=													(.	exp as Expression
														list = List[of Expression]()	.)
	"call"											(.	callToken = t 
														exprToken as Token.)
	ident											(.	proc = t.val .)
	"("
	[
													(.	exprToken = la .)
		Expr<exp>									(.	list.Add(exp); ExpectIntArg(exp, exprToken) .)
		{ 
			"," 									(.	exprToken = la .)
			Expr<exp>								(.	list.Add(exp); ExpectIntArg(exp, exprToken) .)
		}
	]
	")"												(.	callStmt = Call(proc, list, callToken, exprToken) .)
.


Expr<ref exp as Expression>
=	
    LogicOr<exp>                      
.


LogicOr<ref exp as Expression>                	(. second as Expression .)
=	
    LogicAnd<exp>                      
    {
        "or"          							(. tok = t .)
        LogicAnd<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.Or) .)
    }                                       
.

LogicAnd<ref exp as Expression>                	(. second as Expression .)                
=	
    LogicXor<exp>
    {                            
        "and"                    				(. 	tok = t .)
        LogicXor<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.And) .)
    }
.

LogicXor<ref exp as Expression>                	(. second as Expression .)                
=	
    Comparison<exp>
    {                            
        "xor"                    				(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.Xor) .)
    }
.

Comparison<ref exp as Expression>           	(.	second as Expression 
													op as string .)
=
    BitOr<exp>
    [
        (
        "<"                            			(.	op = ComparisonBinaryOp.LessThan .)
        |
        ">"                                		(.	op = ComparisonBinaryOp.GreaterThan .)
        |
        "<="                               		(.	op = ComparisonBinaryOp.LessThanOrEqual .)
        |
        ">="                               		(.	op = ComparisonBinaryOp.GreaterThanOrEqual .)
		|
        "=="                               		(.	op = ComparisonBinaryOp.Equal.)
        |
        "!="                               		(.	op = ComparisonBinaryOp.NotEqual .)
        
        )										(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ComparisonBinaryOp(exp, second, op) .)
    ]
.

BitOr<ref exp as Expression>                	(.	second as Expression .)                  
=	
    BitXor<exp>
    {
        "|"       								(. 	tok = t .)
        BitXor<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Or) .)
    }
.

BitXor<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitAnd<exp>
    {
        "^"     								(.	tok = t .)
        BitAnd<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Xor) .)
    }
.

BitAnd<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitShift<exp>
    {
        "&"                             		(. 	tok = t .)
        BitShift<second>                  		(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.And) .)
    }
.

BitShift<ref exp as Expression>                	(.	second as Expression
													op as string .)               
=	
    PlusMinus<exp>
    {
        (
        "<<"                               		(.	op = BitBinaryOp.ShiftLeft .)
        |
        ">>"                               		(.	op = BitBinaryOp.ShiftRight .)
        )             							(. 	tok = t .)
        PlusMinus<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, op).)
    }
.

PlusMinus<ref exp as Expression>                (. 	second as Expression 
													op as string.)              
=	
    MulDivMod<exp>
    {
        (
        "+"                                		(. 	op = ArithmeticBinaryOp.Plus .)
        |
        "-"                                		(. 	op = ArithmeticBinaryOp.Minus .)
        )             							(. 	tok = t .)
        MulDivMod<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.

MulDivMod<ref exp as Expression>                (. second as Expression .)              
=	
    UnaryOperator<exp>
    {
        (
        "*"                                		(. 	op = ArithmeticBinaryOp.Multiplication .)
        |
        "/"                                		(. 	op = ArithmeticBinaryOp.Division .)
        |
        "%"                                		(. 	op = ArithmeticBinaryOp.Modulo .)
        )             							(. 	tok = t .)
        UnaryOperator<second>          			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.


UnaryOperator<ref exp as Expression>          	(.	op as string = null .)
=                               
	[
	'-'                                    		(. 	op = t.val .)
	|
	'~'                                    		(. 	op = t.val .)
	|
	"not"                                  		(. 	op = t.val .)
												(.	tok = t .)
	]
	Terminal<exp>                      			(.	if op in ('-','~'): 
														return unless ExpectInt(exp, tok, true)
														exp = IntUnaryOp(exp, op)
													elif op == 'not':
														return unless ExpectBool(exp, tok, true)
														exp = NotUnaryOp(exp) .)
.

Terminal<ref exp as Expression>               
=
	( ident                                		(. 	exp = Variable(t.val) 
													if not SymbolTable.IsInScope(t.val) and not CompileOptions.BookVersion:
														errors.SemErr(t.line, t.col, "Undeclared variable '${t.val}'") .)
	| number                               		(. exp = Number(int.Parse(t.val)) .)
	| "true"                               		(. exp = Bool(true) .)
	| "false"                              		(. exp = Bool(false) .)
	| '(' Expr<exp> ')'
	)
.

END Program.
