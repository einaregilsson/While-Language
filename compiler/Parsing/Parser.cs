/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
using System;
using While.AST;
using While.AST.Expressions;
using While.AST.Sequences;
using While.AST.Statements;

namespace While.Parsing {

    public partial class Parser {

        const bool T = true;
        const bool x = false;
        const int minErrDist = 2;

        public Scanner scanner;
        public Errors errors;

        public Token t;    // last recognized token
        public Token la;   // lookahead token
        int errDist = minErrDist;

        public Parser(Scanner scanner) {
            this.scanner = scanner;
            errors = new Errors();
        }

        void SynErr(int n) {
            if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
            errDist = 0;
        }

        public void SemErr(string msg) {
            if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
            errDist = 0;
        }

        void Expect(int n) {
            if (la.kind == n) Get(); else { SynErr(n); }
        }

        bool StartOf(int s) {
            return set[s, la.kind];
        }

        void ExpectWeak(int n, int follow) {
            if (la.kind == n) Get();
            else {
                SynErr(n);
                while (!StartOf(follow)) Get();
            }
        }


        bool WeakSeparator(int n, int syFol, int repFol) {
            int kind = la.kind;
            if (kind == n) { Get(); return true; } else if (StartOf(repFol)) { return false; } else {
                SynErr(n);
                while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
                    Get();
                    kind = la.kind;
                }
                return StartOf(syFol);
            }
        }

        private bool ExpectBool(Expression exp, Token t, bool isRightHandSide) {
	        if (!(exp is TypedExpression<bool>)) {
			    errors.SemErr(t.line, t.col, string.Format("'{0}' expects a boolean expression on its {1} side", t.val, isRightHandSide ? "right" : "left"));
		        return false;
            }
	        return true;
        }

        private bool ExpectInt(Expression exp, Token t, bool isRightHandSide) {
	        if (!(exp is TypedExpression<int>)) {
			    errors.SemErr(t.line, t.col, string.Format("'{0}' expects an integer expression on its {1} side", t.val, isRightHandSide ? "right" : "left"));
		        return false;
            }
	        return true;
        }

        private void ExpectIntArg(Expression exp, Token t) {
            if (!(exp is TypedExpression<int>)) {
                errors.SemErr(t.line, t.col, "Arguments to procedures can only be integer expressions");
            }
        }

        private StatementSequence ToStatementSequence(Statement s) {
            if (s is StatementSequence) {
                return (StatementSequence) s;
            } else {
                StatementSequence seq = new StatementSequence();
                seq.AddStatement(s);
                return seq;
            }
        }

        private SymbolTable SymbolTable {
            get { return While.AST.WhileProgram.SymbolTable; }
        }
        private bool IsStartOfResultArg() {
	        Token t = scanner.Peek();
	        scanner.ResetPeek();
	        return t.val == "res";
        }

        private bool IsProcProgram() {
	        Token t = scanner.Peek();
	        scanner.ResetPeek();
	        return t.val == "proc";
        }

    } // end Parser


    public partial class Errors {
        public int count = 0;                                    // number of errors detected
        public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
        public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

        public void SynErr(int line, int col, int n) {
            string s;
            s = GetErrorMessage(n);
            if (s == null) {
                s = "error " + n;
            }
            errorStream.WriteLine(errMsgFormat, line, col, s);
            count++;
        }

        public void SemErr(int line, int col, string s) {
            errorStream.WriteLine(errMsgFormat, line, col, s);
            count++;
        }

        public void SemErr(string s) {
            errorStream.WriteLine(s);
            count++;
        }

        public void Warning(int line, int col, string s) {
            errorStream.WriteLine(errMsgFormat, line, col, s);
        }

        public void Warning(string s) {
            errorStream.WriteLine(s);
        }
    } // Errors


    public class FatalError : Exception {
        public FatalError(string m) : base(m) { }
    }
}